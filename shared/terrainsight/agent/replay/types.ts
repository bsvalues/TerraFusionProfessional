/**
 * Type definitions for the agent replay system
 * 
 * This file contains type definitions for the replay buffer
 * and experience sharing between agents.
 */

/**
 * Types of experiences that can be stored in the replay buffer
 */
export type ExperienceType = 
  | 'action'       // An action taken by an agent
  | 'error'        // An error encountered by an agent
  | 'decision'     // A decision made by an agent
  | 'observation'  // An observation made by an agent
  | 'result'       // A result produced by an agent
  | 'validation'   // A validation performed by an agent
  | 'communication' // A communication between agents
  | 'assessment';   // An assessment of data or situation

/**
 * Priority levels for experiences
 */
export type ExperiencePriority = 'low' | 'normal' | 'high' | 'critical';

/**
 * An experience recorded by an agent
 */
export interface AgentExperience {
  /** Unique ID for the experience */
  id?: string;
  
  /** ID of the agent that recorded the experience */
  agentId: string;
  
  /** Type of experience */
  type: ExperienceType;
  
  /** Timestamp when the experience was recorded */
  timestamp: string;
  
  /** State before the action/decision */
  state: any;
  
  /** Action taken or decision made */
  action: any;
  
  /** Result of the action (if applicable) */
  result?: any;
  
  /** State after the action (if applicable) */
  nextState?: any;
  
  /** Whether the experience was successful */
  successful?: boolean;
  
  /** Priority of the experience for learning */
  priority?: ExperiencePriority;
  
  /** Number of times this experience has occurred */
  occurrences?: number;
  
  /** Tags for categorizing the experience */
  tags?: string[];
  
  /** Additional context or metadata */
  context?: Record<string, any>;
}

/**
 * Update to an agent's knowledge or behavior based on learning
 */
export interface LearningUpdate {
  /** Unique ID for the update */
  id: string;
  
  /** Timestamp when the update was created */
  timestamp: string;
  
  /** Type of update */
  updateType: 'policy' | 'knowledge' | 'behavior' | 'parameter';
  
  /** Target agent IDs (or 'all' for broadcast) */
  targetAgentIds: string[] | 'all';
  
  /** Description of the update */
  description: string;
  
  /** The updated data */
  data: any;
  
  /** Source experiences that contributed to this update */
  sourceExperienceIds?: string[];
  
  /** Priority of the update */
  priority: ExperiencePriority;
}

/**
 * Configuration for the replay buffer
 */
export interface ReplayBufferConfig {
  /** Maximum size of the buffer */
  maxSize: number;
  
  /** Threshold for initiating training */
  trainingThreshold: number;
  
  /** Whether to prioritize experiences */
  usePrioritization: boolean;
  
  /** Whether to deduplicate similar experiences */
  deduplicateSimilar: boolean;
  
  /** Expiration time for experiences in milliseconds */
  experienceExpirationMs: number | null;
}

/**
 * Training request to update agent behavior
 */
export interface TrainingRequest {
  /** ID of the agent requesting training */
  requestingAgentId: string;
  
  /** Type of training requested */
  trainingType: 'policy' | 'model' | 'parameters';
  
  /** Filter for experiences to include */
  experienceFilter?: {
    agentIds?: string[];
    types?: ExperienceType[];
    minPriority?: ExperiencePriority;
    tags?: string[];
    timeRange?: {
      start: string;
      end: string;
    };
  };
  
  /** Maximum number of experiences to include */
  maxExperiences?: number;
}

/**
 * Result of a training operation
 */
export interface TrainingResult {
  /** Unique ID for the training result */
  id: string;
  
  /** Timestamp when training was completed */
  timestamp: string;
  
  /** Status of the training */
  status: 'success' | 'partial' | 'failed';
  
  /** Updates generated by the training */
  updates: LearningUpdate[];
  
  /** Performance metrics from the training */
  metrics?: {
    experiencesProcessed: number;
    updateCount: number;
    trainingTimeMs: number;
    performanceImprovement?: number;
  };
  
  /** Error information if training failed */
  error?: {
    message: string;
    details: any;
  };
}